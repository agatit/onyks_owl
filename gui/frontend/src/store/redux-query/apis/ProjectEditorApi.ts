// tslint:disable
/**
 * Onyks Wagon Location API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import {
  HttpMethods,
  QueryConfig,
  ResponseBody,
  ResponseText,
} from "redux-query";
import * as runtime from "../runtime";
import {
  Instance,
  InstanceFromJSON,
  InstanceToJSON,
  InstanceModule,
  InstanceModuleFromJSON,
  InstanceModuleToJSON,
  InstanceQueue,
  InstanceQueueFromJSON,
  InstanceQueueToJSON,
  Module,
  ModuleFromJSON,
  ModuleToJSON,
  ModuleDef,
  ModuleDefFromJSON,
  ModuleDefToJSON,
  ProjectResource,
  ProjectResourceFromJSON,
  ProjectResourceToJSON,
  Queue,
  QueueFromJSON,
  QueueToJSON,
} from "../models";

export interface AddInstanceRequest {
  projectId: string;
}

export interface AddModuleRequest {
  projectId: string;
  module: Module;
}

export interface AddQueueRequest {
  projectId: string;
  queue: Queue;
}

export interface AddResourceRequest {
  projectId: string;
}

export interface DeleteModuleRequest {
  projectId: string;
  moduleId: string;
}

export interface DeleteQueueRequest {
  projectId: string;
  moduleId: string;
}

export interface DeleteResourceRequest {
  projectId: string;
  resourceId: string;
}

export interface GetInstanceRequest {
  projectId: string;
  instanceId: string;
}

export interface GetModuleRequest {
  projectId: string;
  moduleId: string;
}

export interface GetQueueRequest {
  projectId: string;
  moduleId: string;
}

export interface GetResourceRequest {
  projectId: string;
  resourceId: string;
}

export interface KillInstanceRequest {
  projectId: string;
  instanceId: string;
}

export interface ListInstanceModulesRequest {
  projectId: string;
  instanceId: string;
}

export interface ListInstanceQueuesRequest {
  projectId: string;
  instanceId: string;
}

export interface ListInstancesRequest {
  projectId: string;
}

export interface ListModulesRequest {
  projectId: string;
}

export interface ListQueuesRequest {
  projectId: string;
}

export interface ListResourcesRequest {
  projectId: string;
}

export interface RunInstanceRequest {
  projectId: string;
}

export interface UpdateModuleRequest {
  projectId: string;
  module: Module;
}

export interface UpdateQueueRequest {
  projectId: string;
  queue: Queue;
}

export interface UpdateResourceRequest {
  projectId: string;
}

/**
 * Add instance to project
 */
function addInstanceRaw<T>(
  requestParameters: AddInstanceRequest,
  requestConfig: runtime.TypedQueryConfig<T, Module> = {}
): QueryConfig<T> {
  if (
    requestParameters.projectId === null ||
    requestParameters.projectId === undefined
  ) {
    throw new runtime.RequiredError(
      "projectId",
      "Required parameter requestParameters.projectId was null or undefined when calling addInstance."
    );
  }

  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  const { meta = {} } = requestConfig;

  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/project({projectId})/instance`.replace(
      `{${"projectId"}}`,
      encodeURIComponent(String(requestParameters.projectId))
    ),
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: "POST",
      headers: headerParameters,
    },
    body: queryParameters,
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) =>
      requestTransform(ModuleFromJSON(body), text);
  }

  return config;
}

/**
 * Add instance to project
 */
export function addInstance<T>(
  requestParameters: AddInstanceRequest,
  requestConfig?: runtime.TypedQueryConfig<T, Module>
): QueryConfig<T> {
  return addInstanceRaw(requestParameters, requestConfig);
}

/**
 * Add module to project
 */
function addModuleRaw<T>(
  requestParameters: AddModuleRequest,
  requestConfig: runtime.TypedQueryConfig<T, Module> = {}
): QueryConfig<T> {
  if (
    requestParameters.projectId === null ||
    requestParameters.projectId === undefined
  ) {
    throw new runtime.RequiredError(
      "projectId",
      "Required parameter requestParameters.projectId was null or undefined when calling addModule."
    );
  }

  if (
    requestParameters.module === null ||
    requestParameters.module === undefined
  ) {
    throw new runtime.RequiredError(
      "module",
      "Required parameter requestParameters.module was null or undefined when calling addModule."
    );
  }

  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  headerParameters["Content-Type"] = "application/json";

  const { meta = {} } = requestConfig;

  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/project({projectId})/module`.replace(
      `{${"projectId"}}`,
      encodeURIComponent(String(requestParameters.projectId))
    ),
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: "POST",
      headers: headerParameters,
    },
    body: queryParameters || ModuleToJSON(requestParameters.module),
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) =>
      requestTransform(ModuleFromJSON(body), text);
  }

  return config;
}

/**
 * Add module to project
 */
export function addModule<T>(
  requestParameters: AddModuleRequest,
  requestConfig?: runtime.TypedQueryConfig<T, Module>
): QueryConfig<T> {
  return addModuleRaw(requestParameters, requestConfig);
}

/**
 * Add queue to project
 */
function addQueueRaw<T>(
  requestParameters: AddQueueRequest,
  requestConfig: runtime.TypedQueryConfig<T, Queue> = {}
): QueryConfig<T> {
  if (
    requestParameters.projectId === null ||
    requestParameters.projectId === undefined
  ) {
    throw new runtime.RequiredError(
      "projectId",
      "Required parameter requestParameters.projectId was null or undefined when calling addQueue."
    );
  }

  if (
    requestParameters.queue === null ||
    requestParameters.queue === undefined
  ) {
    throw new runtime.RequiredError(
      "queue",
      "Required parameter requestParameters.queue was null or undefined when calling addQueue."
    );
  }

  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  headerParameters["Content-Type"] = "application/json";

  const { meta = {} } = requestConfig;

  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/project({projectId})/queue`.replace(
      `{${"projectId"}}`,
      encodeURIComponent(String(requestParameters.projectId))
    ),
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: "POST",
      headers: headerParameters,
    },
    body: queryParameters || QueueToJSON(requestParameters.queue),
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) =>
      requestTransform(QueueFromJSON(body), text);
  }

  return config;
}

/**
 * Add queue to project
 */
export function addQueue<T>(
  requestParameters: AddQueueRequest,
  requestConfig?: runtime.TypedQueryConfig<T, Queue>
): QueryConfig<T> {
  return addQueueRaw(requestParameters, requestConfig);
}

/**
 * Add resource to project
 */
function addResourceRaw<T>(
  requestParameters: AddResourceRequest,
  requestConfig: runtime.TypedQueryConfig<T, ProjectResource> = {}
): QueryConfig<T> {
  if (
    requestParameters.projectId === null ||
    requestParameters.projectId === undefined
  ) {
    throw new runtime.RequiredError(
      "projectId",
      "Required parameter requestParameters.projectId was null or undefined when calling addResource."
    );
  }

  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  const { meta = {} } = requestConfig;

  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/project({projectId})/resource`.replace(
      `{${"projectId"}}`,
      encodeURIComponent(String(requestParameters.projectId))
    ),
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: "POST",
      headers: headerParameters,
    },
    body: queryParameters,
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) =>
      requestTransform(ProjectResourceFromJSON(body), text);
  }

  return config;
}

/**
 * Add resource to project
 */
export function addResource<T>(
  requestParameters: AddResourceRequest,
  requestConfig?: runtime.TypedQueryConfig<T, ProjectResource>
): QueryConfig<T> {
  return addResourceRaw(requestParameters, requestConfig);
}

/**
 * Delete module from project
 */
function deleteModuleRaw<T>(
  requestParameters: DeleteModuleRequest,
  requestConfig: runtime.TypedQueryConfig<T, void> = {}
): QueryConfig<T> {
  if (
    requestParameters.projectId === null ||
    requestParameters.projectId === undefined
  ) {
    throw new runtime.RequiredError(
      "projectId",
      "Required parameter requestParameters.projectId was null or undefined when calling deleteModule."
    );
  }

  if (
    requestParameters.moduleId === null ||
    requestParameters.moduleId === undefined
  ) {
    throw new runtime.RequiredError(
      "moduleId",
      "Required parameter requestParameters.moduleId was null or undefined when calling deleteModule."
    );
  }

  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  const { meta = {} } = requestConfig;

  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/project({projectId})/module({moduleId})`
      .replace(
        `{${"projectId"}}`,
        encodeURIComponent(String(requestParameters.projectId))
      )
      .replace(
        `{${"moduleId"}}`,
        encodeURIComponent(String(requestParameters.moduleId))
      ),
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: "DELETE",
      headers: headerParameters,
    },
    body: queryParameters,
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
  }

  return config;
}

/**
 * Delete module from project
 */
export function deleteModule<T>(
  requestParameters: DeleteModuleRequest,
  requestConfig?: runtime.TypedQueryConfig<T, void>
): QueryConfig<T> {
  return deleteModuleRaw(requestParameters, requestConfig);
}

/**
 * Delete queue from project
 */
function deleteQueueRaw<T>(
  requestParameters: DeleteQueueRequest,
  requestConfig: runtime.TypedQueryConfig<T, void> = {}
): QueryConfig<T> {
  if (
    requestParameters.projectId === null ||
    requestParameters.projectId === undefined
  ) {
    throw new runtime.RequiredError(
      "projectId",
      "Required parameter requestParameters.projectId was null or undefined when calling deleteQueue."
    );
  }

  if (
    requestParameters.moduleId === null ||
    requestParameters.moduleId === undefined
  ) {
    throw new runtime.RequiredError(
      "moduleId",
      "Required parameter requestParameters.moduleId was null or undefined when calling deleteQueue."
    );
  }

  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  const { meta = {} } = requestConfig;

  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/project({projectId})/queue({moduleId})`
      .replace(
        `{${"projectId"}}`,
        encodeURIComponent(String(requestParameters.projectId))
      )
      .replace(
        `{${"moduleId"}}`,
        encodeURIComponent(String(requestParameters.moduleId))
      ),
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: "DELETE",
      headers: headerParameters,
    },
    body: queryParameters,
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
  }

  return config;
}

/**
 * Delete queue from project
 */
export function deleteQueue<T>(
  requestParameters: DeleteQueueRequest,
  requestConfig?: runtime.TypedQueryConfig<T, void>
): QueryConfig<T> {
  return deleteQueueRaw(requestParameters, requestConfig);
}

/**
 * Delete resource from project
 */
function deleteResourceRaw<T>(
  requestParameters: DeleteResourceRequest,
  requestConfig: runtime.TypedQueryConfig<T, void> = {}
): QueryConfig<T> {
  if (
    requestParameters.projectId === null ||
    requestParameters.projectId === undefined
  ) {
    throw new runtime.RequiredError(
      "projectId",
      "Required parameter requestParameters.projectId was null or undefined when calling deleteResource."
    );
  }

  if (
    requestParameters.resourceId === null ||
    requestParameters.resourceId === undefined
  ) {
    throw new runtime.RequiredError(
      "resourceId",
      "Required parameter requestParameters.resourceId was null or undefined when calling deleteResource."
    );
  }

  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  const { meta = {} } = requestConfig;

  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/project({projectId})/resource({resourceId})`
      .replace(
        `{${"projectId"}}`,
        encodeURIComponent(String(requestParameters.projectId))
      )
      .replace(
        `{${"resourceId"}}`,
        encodeURIComponent(String(requestParameters.resourceId))
      ),
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: "DELETE",
      headers: headerParameters,
    },
    body: queryParameters,
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
  }

  return config;
}

/**
 * Delete resource from project
 */
export function deleteResource<T>(
  requestParameters: DeleteResourceRequest,
  requestConfig?: runtime.TypedQueryConfig<T, void>
): QueryConfig<T> {
  return deleteResourceRaw(requestParameters, requestConfig);
}

/**
 * Get specified of project instance
 */
function getInstanceRaw<T>(
  requestParameters: GetInstanceRequest,
  requestConfig: runtime.TypedQueryConfig<T, Instance> = {}
): QueryConfig<T> {
  if (
    requestParameters.projectId === null ||
    requestParameters.projectId === undefined
  ) {
    throw new runtime.RequiredError(
      "projectId",
      "Required parameter requestParameters.projectId was null or undefined when calling getInstance."
    );
  }

  if (
    requestParameters.instanceId === null ||
    requestParameters.instanceId === undefined
  ) {
    throw new runtime.RequiredError(
      "instanceId",
      "Required parameter requestParameters.instanceId was null or undefined when calling getInstance."
    );
  }

  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  const { meta = {} } = requestConfig;

  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/project({projectId})/instance({instanceId})`
      .replace(
        `{${"projectId"}}`,
        encodeURIComponent(String(requestParameters.projectId))
      )
      .replace(
        `{${"instanceId"}}`,
        encodeURIComponent(String(requestParameters.instanceId))
      ),
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: "GET",
      headers: headerParameters,
    },
    body: queryParameters,
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) =>
      requestTransform(InstanceFromJSON(body), text);
  }

  return config;
}

/**
 * Get specified of project instance
 */
export function getInstance<T>(
  requestParameters: GetInstanceRequest,
  requestConfig?: runtime.TypedQueryConfig<T, Instance>
): QueryConfig<T> {
  return getInstanceRaw(requestParameters, requestConfig);
}

/**
 * Get specified project module
 */
function getModuleRaw<T>(
  requestParameters: GetModuleRequest,
  requestConfig: runtime.TypedQueryConfig<T, Module> = {}
): QueryConfig<T> {
  if (
    requestParameters.projectId === null ||
    requestParameters.projectId === undefined
  ) {
    throw new runtime.RequiredError(
      "projectId",
      "Required parameter requestParameters.projectId was null or undefined when calling getModule."
    );
  }

  if (
    requestParameters.moduleId === null ||
    requestParameters.moduleId === undefined
  ) {
    throw new runtime.RequiredError(
      "moduleId",
      "Required parameter requestParameters.moduleId was null or undefined when calling getModule."
    );
  }

  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  const { meta = {} } = requestConfig;

  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/project({projectId})/module({moduleId})`
      .replace(
        `{${"projectId"}}`,
        encodeURIComponent(String(requestParameters.projectId))
      )
      .replace(
        `{${"moduleId"}}`,
        encodeURIComponent(String(requestParameters.moduleId))
      ),
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: "GET",
      headers: headerParameters,
    },
    body: queryParameters,
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) =>
      requestTransform(ModuleFromJSON(body), text);
  }

  return config;
}

/**
 * Get specified project module
 */
export function getModule<T>(
  requestParameters: GetModuleRequest,
  requestConfig?: runtime.TypedQueryConfig<T, Module>
): QueryConfig<T> {
  return getModuleRaw(requestParameters, requestConfig);
}

/**
 * Get specified of project queue
 */
function getQueueRaw<T>(
  requestParameters: GetQueueRequest,
  requestConfig: runtime.TypedQueryConfig<T, Queue> = {}
): QueryConfig<T> {
  if (
    requestParameters.projectId === null ||
    requestParameters.projectId === undefined
  ) {
    throw new runtime.RequiredError(
      "projectId",
      "Required parameter requestParameters.projectId was null or undefined when calling getQueue."
    );
  }

  if (
    requestParameters.moduleId === null ||
    requestParameters.moduleId === undefined
  ) {
    throw new runtime.RequiredError(
      "moduleId",
      "Required parameter requestParameters.moduleId was null or undefined when calling getQueue."
    );
  }

  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  const { meta = {} } = requestConfig;

  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/project({projectId})/queue({moduleId})`
      .replace(
        `{${"projectId"}}`,
        encodeURIComponent(String(requestParameters.projectId))
      )
      .replace(
        `{${"moduleId"}}`,
        encodeURIComponent(String(requestParameters.moduleId))
      ),
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: "GET",
      headers: headerParameters,
    },
    body: queryParameters,
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) =>
      requestTransform(QueueFromJSON(body), text);
  }

  return config;
}

/**
 * Get specified of project queue
 */
export function getQueue<T>(
  requestParameters: GetQueueRequest,
  requestConfig?: runtime.TypedQueryConfig<T, Queue>
): QueryConfig<T> {
  return getQueueRaw(requestParameters, requestConfig);
}

/**
 * Get specified of project resource
 */
function getResourceRaw<T>(
  requestParameters: GetResourceRequest,
  requestConfig: runtime.TypedQueryConfig<T, ProjectResource> = {}
): QueryConfig<T> {
  if (
    requestParameters.projectId === null ||
    requestParameters.projectId === undefined
  ) {
    throw new runtime.RequiredError(
      "projectId",
      "Required parameter requestParameters.projectId was null or undefined when calling getResource."
    );
  }

  if (
    requestParameters.resourceId === null ||
    requestParameters.resourceId === undefined
  ) {
    throw new runtime.RequiredError(
      "resourceId",
      "Required parameter requestParameters.resourceId was null or undefined when calling getResource."
    );
  }

  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  const { meta = {} } = requestConfig;

  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/project({projectId})/resource({resourceId})`
      .replace(
        `{${"projectId"}}`,
        encodeURIComponent(String(requestParameters.projectId))
      )
      .replace(
        `{${"resourceId"}}`,
        encodeURIComponent(String(requestParameters.resourceId))
      ),
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: "GET",
      headers: headerParameters,
    },
    body: queryParameters,
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) =>
      requestTransform(ProjectResourceFromJSON(body), text);
  }

  return config;
}

/**
 * Get specified of project resource
 */
export function getResource<T>(
  requestParameters: GetResourceRequest,
  requestConfig?: runtime.TypedQueryConfig<T, ProjectResource>
): QueryConfig<T> {
  return getResourceRaw(requestParameters, requestConfig);
}

/**
 * Delete instance from project
 */
function killInstanceRaw<T>(
  requestParameters: KillInstanceRequest,
  requestConfig: runtime.TypedQueryConfig<T, void> = {}
): QueryConfig<T> {
  if (
    requestParameters.projectId === null ||
    requestParameters.projectId === undefined
  ) {
    throw new runtime.RequiredError(
      "projectId",
      "Required parameter requestParameters.projectId was null or undefined when calling killInstance."
    );
  }

  if (
    requestParameters.instanceId === null ||
    requestParameters.instanceId === undefined
  ) {
    throw new runtime.RequiredError(
      "instanceId",
      "Required parameter requestParameters.instanceId was null or undefined when calling killInstance."
    );
  }

  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  const { meta = {} } = requestConfig;

  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/project({projectId})/instance({instanceId})`
      .replace(
        `{${"projectId"}}`,
        encodeURIComponent(String(requestParameters.projectId))
      )
      .replace(
        `{${"instanceId"}}`,
        encodeURIComponent(String(requestParameters.instanceId))
      ),
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: "DELETE",
      headers: headerParameters,
    },
    body: queryParameters,
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
  }

  return config;
}

/**
 * Delete instance from project
 */
export function killInstance<T>(
  requestParameters: KillInstanceRequest,
  requestConfig?: runtime.TypedQueryConfig<T, void>
): QueryConfig<T> {
  return killInstanceRaw(requestParameters, requestConfig);
}

/**
 * Get specified project instance
 */
function listInstanceModulesRaw<T>(
  requestParameters: ListInstanceModulesRequest,
  requestConfig: runtime.TypedQueryConfig<T, Array<InstanceModule>> = {}
): QueryConfig<T> {
  if (
    requestParameters.projectId === null ||
    requestParameters.projectId === undefined
  ) {
    throw new runtime.RequiredError(
      "projectId",
      "Required parameter requestParameters.projectId was null or undefined when calling listInstanceModules."
    );
  }

  if (
    requestParameters.instanceId === null ||
    requestParameters.instanceId === undefined
  ) {
    throw new runtime.RequiredError(
      "instanceId",
      "Required parameter requestParameters.instanceId was null or undefined when calling listInstanceModules."
    );
  }

  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  const { meta = {} } = requestConfig;

  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/project({projectId})/instance({instanceId})/module`
      .replace(
        `{${"projectId"}}`,
        encodeURIComponent(String(requestParameters.projectId))
      )
      .replace(
        `{${"instanceId"}}`,
        encodeURIComponent(String(requestParameters.instanceId))
      ),
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: "GET",
      headers: headerParameters,
    },
    body: queryParameters,
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) =>
      requestTransform(body.map(InstanceModuleFromJSON), text);
  }

  return config;
}

/**
 * Get specified project instance
 */
export function listInstanceModules<T>(
  requestParameters: ListInstanceModulesRequest,
  requestConfig?: runtime.TypedQueryConfig<T, Array<InstanceModule>>
): QueryConfig<T> {
  return listInstanceModulesRaw(requestParameters, requestConfig);
}

/**
 * Get specified project instance
 */
function listInstanceQueuesRaw<T>(
  requestParameters: ListInstanceQueuesRequest,
  requestConfig: runtime.TypedQueryConfig<T, Array<InstanceQueue>> = {}
): QueryConfig<T> {
  if (
    requestParameters.projectId === null ||
    requestParameters.projectId === undefined
  ) {
    throw new runtime.RequiredError(
      "projectId",
      "Required parameter requestParameters.projectId was null or undefined when calling listInstanceQueues."
    );
  }

  if (
    requestParameters.instanceId === null ||
    requestParameters.instanceId === undefined
  ) {
    throw new runtime.RequiredError(
      "instanceId",
      "Required parameter requestParameters.instanceId was null or undefined when calling listInstanceQueues."
    );
  }

  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  const { meta = {} } = requestConfig;

  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/project({projectId})/instance({instanceId})/queue`
      .replace(
        `{${"projectId"}}`,
        encodeURIComponent(String(requestParameters.projectId))
      )
      .replace(
        `{${"instanceId"}}`,
        encodeURIComponent(String(requestParameters.instanceId))
      ),
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: "GET",
      headers: headerParameters,
    },
    body: queryParameters,
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) =>
      requestTransform(body.map(InstanceQueueFromJSON), text);
  }

  return config;
}

/**
 * Get specified project instance
 */
export function listInstanceQueues<T>(
  requestParameters: ListInstanceQueuesRequest,
  requestConfig?: runtime.TypedQueryConfig<T, Array<InstanceQueue>>
): QueryConfig<T> {
  return listInstanceQueuesRaw(requestParameters, requestConfig);
}

/**
 * Get list of project instances
 */
function listInstancesRaw<T>(
  requestParameters: ListInstancesRequest,
  requestConfig: runtime.TypedQueryConfig<T, Array<Instance>> = {}
): QueryConfig<T> {
  if (
    requestParameters.projectId === null ||
    requestParameters.projectId === undefined
  ) {
    throw new runtime.RequiredError(
      "projectId",
      "Required parameter requestParameters.projectId was null or undefined when calling listInstances."
    );
  }

  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  const { meta = {} } = requestConfig;

  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/project({projectId})/instance`.replace(
      `{${"projectId"}}`,
      encodeURIComponent(String(requestParameters.projectId))
    ),
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: "GET",
      headers: headerParameters,
    },
    body: queryParameters,
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) =>
      requestTransform(body.map(InstanceFromJSON), text);
  }

  return config;
}

/**
 * Get list of project instances
 */
export function listInstances<T>(
  requestParameters: ListInstancesRequest,
  requestConfig?: runtime.TypedQueryConfig<T, Array<Instance>>
): QueryConfig<T> {
  return listInstancesRaw(requestParameters, requestConfig);
}

/**
 * Get list of module definitions
 */
function listModuleDefRaw<T>(
  requestConfig: runtime.TypedQueryConfig<T, Array<ModuleDef>> = {}
): QueryConfig<T> {
  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  const { meta = {} } = requestConfig;

  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/module_def`,
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: "GET",
      headers: headerParameters,
    },
    body: queryParameters,
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) =>
      requestTransform(body.map(ModuleDefFromJSON), text);
  }

  return config;
}

/**
 * Get list of module definitions
 */
export function listModuleDef<T>(
  requestConfig?: runtime.TypedQueryConfig<T, Array<ModuleDef>>
): QueryConfig<T> {
  return listModuleDefRaw(requestConfig);
}

/**
 * Get list of project modules
 */
function listModulesRaw<T>(
  requestParameters: ListModulesRequest,
  requestConfig: runtime.TypedQueryConfig<T, Array<Module>> = {}
): QueryConfig<T> {
  if (
    requestParameters.projectId === null ||
    requestParameters.projectId === undefined
  ) {
    throw new runtime.RequiredError(
      "projectId",
      "Required parameter requestParameters.projectId was null or undefined when calling listModules."
    );
  }

  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  const { meta = {} } = requestConfig;

  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/project({projectId})/module.json`.replace(
      `{${"projectId"}}`,
      encodeURIComponent(String(requestParameters.projectId))
    ),
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: "GET",
      headers: headerParameters,
    },
    body: queryParameters,
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) =>
      requestTransform(body.map(ModuleFromJSON), text);
  }

  return config;
}

/**
 * Get list of project modules
 */
export function listModules<T>(
  requestParameters: ListModulesRequest,
  requestConfig?: runtime.TypedQueryConfig<T, Array<Module>>
): QueryConfig<T> {
  return listModulesRaw(requestParameters, requestConfig);
}

/**
 * Get list of project queues
 */
function listQueuesRaw<T>(
  requestParameters: ListQueuesRequest,
  requestConfig: runtime.TypedQueryConfig<T, Array<Queue>> = {}
): QueryConfig<T> {
  if (
    requestParameters.projectId === null ||
    requestParameters.projectId === undefined
  ) {
    throw new runtime.RequiredError(
      "projectId",
      "Required parameter requestParameters.projectId was null or undefined when calling listQueues."
    );
  }

  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  const { meta = {} } = requestConfig;

  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/project({projectId})/queue`.replace(
      `{${"projectId"}}`,
      encodeURIComponent(String(requestParameters.projectId))
    ),
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: "GET",
      headers: headerParameters,
    },
    body: queryParameters,
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) =>
      requestTransform(body.map(QueueFromJSON), text);
  }

  return config;
}

/**
 * Get list of project queues
 */
export function listQueues<T>(
  requestParameters: ListQueuesRequest,
  requestConfig?: runtime.TypedQueryConfig<T, Array<Queue>>
): QueryConfig<T> {
  return listQueuesRaw(requestParameters, requestConfig);
}

/**
 * Get list of project resources
 */
function listResourcesRaw<T>(
  requestParameters: ListResourcesRequest,
  requestConfig: runtime.TypedQueryConfig<T, Array<ProjectResource>> = {}
): QueryConfig<T> {
  if (
    requestParameters.projectId === null ||
    requestParameters.projectId === undefined
  ) {
    throw new runtime.RequiredError(
      "projectId",
      "Required parameter requestParameters.projectId was null or undefined when calling listResources."
    );
  }

  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  const { meta = {} } = requestConfig;

  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/project({projectId})/resource`.replace(
      `{${"projectId"}}`,
      encodeURIComponent(String(requestParameters.projectId))
    ),
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: "GET",
      headers: headerParameters,
    },
    body: queryParameters,
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) =>
      requestTransform(body.map(ProjectResourceFromJSON), text);
  }

  return config;
}

/**
 * Get list of project resources
 */
export function listResources<T>(
  requestParameters: ListResourcesRequest,
  requestConfig?: runtime.TypedQueryConfig<T, Array<ProjectResource>>
): QueryConfig<T> {
  return listResourcesRaw(requestParameters, requestConfig);
}

/**
 * Update instance to project
 */
function runInstanceRaw<T>(
  requestParameters: RunInstanceRequest,
  requestConfig: runtime.TypedQueryConfig<T, Module> = {}
): QueryConfig<T> {
  if (
    requestParameters.projectId === null ||
    requestParameters.projectId === undefined
  ) {
    throw new runtime.RequiredError(
      "projectId",
      "Required parameter requestParameters.projectId was null or undefined when calling runInstance."
    );
  }

  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  const { meta = {} } = requestConfig;

  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/project({projectId})/instance`.replace(
      `{${"projectId"}}`,
      encodeURIComponent(String(requestParameters.projectId))
    ),
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: "PUT",
      headers: headerParameters,
    },
    body: queryParameters,
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) =>
      requestTransform(ModuleFromJSON(body), text);
  }

  return config;
}

/**
 * Update instance to project
 */
export function runInstance<T>(
  requestParameters: RunInstanceRequest,
  requestConfig?: runtime.TypedQueryConfig<T, Module>
): QueryConfig<T> {
  return runInstanceRaw(requestParameters, requestConfig);
}

/**
 * Add module to project
 */
function updateModuleRaw<T>(
  requestParameters: UpdateModuleRequest,
  requestConfig: runtime.TypedQueryConfig<T, Module> = {}
): QueryConfig<T> {
  if (
    requestParameters.projectId === null ||
    requestParameters.projectId === undefined
  ) {
    throw new runtime.RequiredError(
      "projectId",
      "Required parameter requestParameters.projectId was null or undefined when calling updateModule."
    );
  }

  if (
    requestParameters.module === null ||
    requestParameters.module === undefined
  ) {
    throw new runtime.RequiredError(
      "module",
      "Required parameter requestParameters.module was null or undefined when calling updateModule."
    );
  }

  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  headerParameters["Content-Type"] = "application/json";

  const { meta = {} } = requestConfig;

  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/project({projectId})/module`.replace(
      `{${"projectId"}}`,
      encodeURIComponent(String(requestParameters.projectId))
    ),
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: "PUT",
      headers: headerParameters,
    },
    body: queryParameters || ModuleToJSON(requestParameters.module),
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) =>
      requestTransform(ModuleFromJSON(body), text);
  }

  return config;
}

/**
 * Add module to project
 */
export function updateModule<T>(
  requestParameters: UpdateModuleRequest,
  requestConfig?: runtime.TypedQueryConfig<T, Module>
): QueryConfig<T> {
  return updateModuleRaw(requestParameters, requestConfig);
}

/**
 * Update queue to project
 */
function updateQueueRaw<T>(
  requestParameters: UpdateQueueRequest,
  requestConfig: runtime.TypedQueryConfig<T, Queue> = {}
): QueryConfig<T> {
  if (
    requestParameters.projectId === null ||
    requestParameters.projectId === undefined
  ) {
    throw new runtime.RequiredError(
      "projectId",
      "Required parameter requestParameters.projectId was null or undefined when calling updateQueue."
    );
  }

  if (
    requestParameters.queue === null ||
    requestParameters.queue === undefined
  ) {
    throw new runtime.RequiredError(
      "queue",
      "Required parameter requestParameters.queue was null or undefined when calling updateQueue."
    );
  }

  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  headerParameters["Content-Type"] = "application/json";

  const { meta = {} } = requestConfig;

  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/project({projectId})/queue`.replace(
      `{${"projectId"}}`,
      encodeURIComponent(String(requestParameters.projectId))
    ),
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: "PUT",
      headers: headerParameters,
    },
    body: queryParameters || QueueToJSON(requestParameters.queue),
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) =>
      requestTransform(QueueFromJSON(body), text);
  }

  return config;
}

/**
 * Update queue to project
 */
export function updateQueue<T>(
  requestParameters: UpdateQueueRequest,
  requestConfig?: runtime.TypedQueryConfig<T, Queue>
): QueryConfig<T> {
  return updateQueueRaw(requestParameters, requestConfig);
}

/**
 * Update resource to project
 */
function updateResourceRaw<T>(
  requestParameters: UpdateResourceRequest,
  requestConfig: runtime.TypedQueryConfig<T, Module> = {}
): QueryConfig<T> {
  if (
    requestParameters.projectId === null ||
    requestParameters.projectId === undefined
  ) {
    throw new runtime.RequiredError(
      "projectId",
      "Required parameter requestParameters.projectId was null or undefined when calling updateResource."
    );
  }

  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  const { meta = {} } = requestConfig;

  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/project({projectId})/resource`.replace(
      `{${"projectId"}}`,
      encodeURIComponent(String(requestParameters.projectId))
    ),
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: "PUT",
      headers: headerParameters,
    },
    body: queryParameters,
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) =>
      requestTransform(ModuleFromJSON(body), text);
  }

  return config;
}

/**
 * Update resource to project
 */
export function updateResource<T>(
  requestParameters: UpdateResourceRequest,
  requestConfig?: runtime.TypedQueryConfig<T, Module>
): QueryConfig<T> {
  return updateResourceRaw(requestParameters, requestConfig);
}
