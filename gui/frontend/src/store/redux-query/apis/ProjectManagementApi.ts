// tslint:disable
/**
 * Onyks Wagon Location API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import {
  HttpMethods,
  QueryConfig,
  ResponseBody,
  ResponseText,
} from "redux-query";
import * as runtime from "../runtime";
import { Project, ProjectFromJSON, ProjectToJSON } from "../models";

export interface AddProjectRequest {
  project: Project;
}

export interface DeleteProjectRequest {
  projectId: string;
}

export interface GetProjectRequest {
  projectId: string;
}

export interface UpdateProjectRequest {
  project: Project;
}

/**
 * Adding new project
 */
function addProjectRaw<T>(
  requestParameters: AddProjectRequest,
  requestConfig: runtime.TypedQueryConfig<T, Project> = {}
): QueryConfig<T> {
  if (
    requestParameters.project === null ||
    requestParameters.project === undefined
  ) {
    throw new runtime.RequiredError(
      "project",
      "Required parameter requestParameters.project was null or undefined when calling addProject."
    );
  }

  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  headerParameters["Content-Type"] = "application/json";

  const { meta = {} } = requestConfig;

  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/project`,
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: "POST",
      headers: headerParameters,
    },
    body: queryParameters || ProjectToJSON(requestParameters.project),
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) =>
      requestTransform(ProjectFromJSON(body), text);
  }

  return config;
}

/**
 * Adding new project
 */
export function addProject<T>(
  requestParameters: AddProjectRequest,
  requestConfig?: runtime.TypedQueryConfig<T, Project>
): QueryConfig<T> {
  return addProjectRaw(requestParameters, requestConfig);
}

/**
 * Deletes a Project
 */
function deleteProjectRaw<T>(
  requestParameters: DeleteProjectRequest,
  requestConfig: runtime.TypedQueryConfig<T, void> = {}
): QueryConfig<T> {
  if (
    requestParameters.projectId === null ||
    requestParameters.projectId === undefined
  ) {
    throw new runtime.RequiredError(
      "projectId",
      "Required parameter requestParameters.projectId was null or undefined when calling deleteProject."
    );
  }

  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  const { meta = {} } = requestConfig;

  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/project({projectId})`.replace(
      `{${"projectId"}}`,
      encodeURIComponent(String(requestParameters.projectId))
    ),
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: "DELETE",
      headers: headerParameters,
    },
    body: queryParameters,
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
  }

  return config;
}

/**
 * Deletes a Project
 */
export function deleteProject<T>(
  requestParameters: DeleteProjectRequest,
  requestConfig?: runtime.TypedQueryConfig<T, void>
): QueryConfig<T> {
  return deleteProjectRaw(requestParameters, requestConfig);
}

/**
 * Returns a single project
 * Find Project by ID
 */
function getProjectRaw<T>(
  requestParameters: GetProjectRequest,
  requestConfig: runtime.TypedQueryConfig<T, Project> = {}
): QueryConfig<T> {
  if (
    requestParameters.projectId === null ||
    requestParameters.projectId === undefined
  ) {
    throw new runtime.RequiredError(
      "projectId",
      "Required parameter requestParameters.projectId was null or undefined when calling getProject."
    );
  }

  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  const { meta = {} } = requestConfig;

  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/project({projectId}).json`.replace(
      `{${"projectId"}}`,
      encodeURIComponent(String(requestParameters.projectId))
    ),
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: "GET",
      headers: headerParameters,
    },
    body: queryParameters,
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) =>
      requestTransform(ProjectFromJSON(body), text);
  }

  return config;
}

/**
 * Returns a single project
 * Find Project by ID
 */
export function getProject<T>(
  requestParameters: GetProjectRequest,
  requestConfig?: runtime.TypedQueryConfig<T, Project>
): QueryConfig<T> {
  return getProjectRaw(requestParameters, requestConfig);
}

/**
 * Get list of projects
 */
function listProjectsRaw<T>(
  requestConfig: runtime.TypedQueryConfig<T, Array<Project>> = {}
): QueryConfig<T> {
  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  const { meta = {} } = requestConfig;

  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/project.json`,
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: "GET",
      headers: headerParameters,
    },
    body: queryParameters,
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) =>
      requestTransform(body.map(ProjectFromJSON), text);
  }

  return config;
}

/**
 * Get list of projects
 */
export function listProjects<T>(
  requestConfig?: runtime.TypedQueryConfig<T, Array<Project>>
): QueryConfig<T> {
  return listProjectsRaw(requestConfig);
}

/**
 * Updates a Project
 */
function updateProjectRaw<T>(
  requestParameters: UpdateProjectRequest,
  requestConfig: runtime.TypedQueryConfig<T, Project> = {}
): QueryConfig<T> {
  if (
    requestParameters.project === null ||
    requestParameters.project === undefined
  ) {
    throw new runtime.RequiredError(
      "project",
      "Required parameter requestParameters.project was null or undefined when calling updateProject."
    );
  }

  let queryParameters = null;

  const headerParameters: runtime.HttpHeaders = {};

  headerParameters["Content-Type"] = "application/json";

  const { meta = {} } = requestConfig;

  const config: QueryConfig<T> = {
    url: `${runtime.Configuration.basePath}/project`,
    meta,
    update: requestConfig.update,
    queryKey: requestConfig.queryKey,
    optimisticUpdate: requestConfig.optimisticUpdate,
    force: requestConfig.force,
    rollback: requestConfig.rollback,
    options: {
      method: "PUT",
      headers: headerParameters,
    },
    body: queryParameters || ProjectToJSON(requestParameters.project),
  };

  const { transform: requestTransform } = requestConfig;
  if (requestTransform) {
    config.transform = (body: ResponseBody, text: ResponseBody) =>
      requestTransform(ProjectFromJSON(body), text);
  }

  return config;
}

/**
 * Updates a Project
 */
export function updateProject<T>(
  requestParameters: UpdateProjectRequest,
  requestConfig?: runtime.TypedQueryConfig<T, Project>
): QueryConfig<T> {
  return updateProjectRaw(requestParameters, requestConfig);
}
